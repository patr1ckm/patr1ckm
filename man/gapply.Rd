% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gapply.R
\name{gapply}
\alias{gapply}
\title{Repeatedly apply a function over a grid of values in parallel}
\usage{
gapply(f, reps = 1, mc.cores = 1, verbose = 1, ...)
}
\arguments{
\item{f}{function to be evaluated. The function must return a (named) value or (named) vector of values.}

\item{reps}{times the function should be evaluated}

\item{mc.cores}{attempts to split function evaluations over given number of cores}

\item{verbose}{If \code{1} (default), prints a \code{.} with every completed condition. 
If \code{2}, prints the arguments corresponding to the completed condition. 
If \code{3}, prints the arguments and results of the completed condition.}

\item{...}{named arguments to \code{f} in the form \code{key=c(value1,value2, ...)} etc. 
A grid of parameter values will be generated from values given to each named argument, as \code{expand.grid(...)}}
}
\value{
Returns results as a \code{data.frame} in long form with the following columns:
\item{\code{param.id}}{the row of \code{expand.grid(...)}}
\item{...}{Columns corresponding to grid of parameters given in \code{expand.grid(...)}}
\item{\code{rep}}{giving the replication number}
\item{\code{key}}{giving the name(s) of the return value(s) of \code{f}}
\item{\code{value}}{gives the value}
}
\description{
gapply (grid apply) applies a function to a grid of it's parameters in parallel, optionally for a given number of replications
}
\details{
If the values returned by \code{f} are not named, they will be named according to the rules of \code{as.data.frame}, typically \code{V1, V2, ...}. 
Note that the function application to each combination of meta-parameters (not replications) are distributed in parallel, will not work in Windows.
}
\examples{
do.one <- function(a=1,b=2){c(sum=a+b,sub=a-b)}
gapply(do.one,reps=5, a=1:4,b=2:3)
}

